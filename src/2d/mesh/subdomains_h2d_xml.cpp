// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "2d/mesh/subdomains_h2d_xml.h"

namespace XMLSubdomains
{
  // elements_type
  // 

  const elements_type::el_sequence& elements_type::
  el () const
  {
    return this->el_;
  }

  elements_type::el_sequence& elements_type::
  el ()
  {
    return this->el_;
  }

  void elements_type::
  el (const el_sequence& s)
  {
    this->el_ = s;
  }


  // el_t
  // 

  const el_t::v1_type& el_t::
  v1 () const
  {
    return this->v1_.get ();
  }

  el_t::v1_type& el_t::
  v1 ()
  {
    return this->v1_.get ();
  }

  void el_t::
  v1 (const v1_type& x)
  {
    this->v1_.set (x);
  }

  const el_t::v2_type& el_t::
  v2 () const
  {
    return this->v2_.get ();
  }

  el_t::v2_type& el_t::
  v2 ()
  {
    return this->v2_.get ();
  }

  void el_t::
  v2 (const v2_type& x)
  {
    this->v2_.set (x);
  }

  const el_t::v3_type& el_t::
  v3 () const
  {
    return this->v3_.get ();
  }

  el_t::v3_type& el_t::
  v3 ()
  {
    return this->v3_.get ();
  }

  void el_t::
  v3 (const v3_type& x)
  {
    this->v3_.set (x);
  }

  const el_t::m_type& el_t::
  m () const
  {
    return this->m_.get ();
  }

  el_t::m_type& el_t::
  m ()
  {
    return this->m_.get ();
  }

  void el_t::
  m (const m_type& x)
  {
    this->m_.set (x);
  }

  void el_t::
  m (::std::auto_ptr< m_type > x)
  {
    this->m_.set (x);
  }

  const el_t::i_type& el_t::
  i () const
  {
    return this->i_.get ();
  }

  el_t::i_type& el_t::
  i ()
  {
    return this->i_.get ();
  }

  void el_t::
  i (const i_type& x)
  {
    this->i_.set (x);
  }


  // t_t
  // 


  // q_t
  // 

  const q_t::v4_type& q_t::
  v4 () const
  {
    return this->v4_.get ();
  }

  q_t::v4_type& q_t::
  v4 ()
  {
    return this->v4_.get ();
  }

  void q_t::
  v4 (const v4_type& x)
  {
    this->v4_.set (x);
  }


  // edges_type
  // 

  const edges_type::ed_sequence& edges_type::
  ed () const
  {
    return this->ed_;
  }

  edges_type::ed_sequence& edges_type::
  ed ()
  {
    return this->ed_;
  }

  void edges_type::
  ed (const ed_sequence& s)
  {
    this->ed_ = s;
  }


  // domain
  // 

  const domain::variables_optional& domain::
  variables () const
  {
    return this->variables_;
  }

  domain::variables_optional& domain::
  variables ()
  {
    return this->variables_;
  }

  void domain::
  variables (const variables_type& x)
  {
    this->variables_.set (x);
  }

  void domain::
  variables (const variables_optional& x)
  {
    this->variables_ = x;
  }

  void domain::
  variables (::std::auto_ptr< variables_type > x)
  {
    this->variables_.set (x);
  }

  const domain::vertices_type& domain::
  vertices () const
  {
    return this->vertices_.get ();
  }

  domain::vertices_type& domain::
  vertices ()
  {
    return this->vertices_.get ();
  }

  void domain::
  vertices (const vertices_type& x)
  {
    this->vertices_.set (x);
  }

  void domain::
  vertices (::std::auto_ptr< vertices_type > x)
  {
    this->vertices_.set (x);
  }

  const domain::elements_type& domain::
  elements () const
  {
    return this->elements_.get ();
  }

  domain::elements_type& domain::
  elements ()
  {
    return this->elements_.get ();
  }

  void domain::
  elements (const elements_type& x)
  {
    this->elements_.set (x);
  }

  void domain::
  elements (::std::auto_ptr< elements_type > x)
  {
    this->elements_.set (x);
  }

  const domain::edges_type& domain::
  edges () const
  {
    return this->edges_.get ();
  }

  domain::edges_type& domain::
  edges ()
  {
    return this->edges_.get ();
  }

  void domain::
  edges (const edges_type& x)
  {
    this->edges_.set (x);
  }

  void domain::
  edges (::std::auto_ptr< edges_type > x)
  {
    this->edges_.set (x);
  }

  const domain::curves_optional& domain::
  curves () const
  {
    return this->curves_;
  }

  domain::curves_optional& domain::
  curves ()
  {
    return this->curves_;
  }

  void domain::
  curves (const curves_type& x)
  {
    this->curves_.set (x);
  }

  void domain::
  curves (const curves_optional& x)
  {
    this->curves_ = x;
  }

  void domain::
  curves (::std::auto_ptr< curves_type > x)
  {
    this->curves_.set (x);
  }

  const domain::subdomains_type& domain::
  subdomains () const
  {
    return this->subdomains_.get ();
  }

  domain::subdomains_type& domain::
  subdomains ()
  {
    return this->subdomains_.get ();
  }

  void domain::
  subdomains (const subdomains_type& x)
  {
    this->subdomains_.set (x);
  }

  void domain::
  subdomains (::std::auto_ptr< subdomains_type > x)
  {
    this->subdomains_.set (x);
  }


  // ed
  // 

  const ed::v1_type& ed::
  v1 () const
  {
    return this->v1_.get ();
  }

  ed::v1_type& ed::
  v1 ()
  {
    return this->v1_.get ();
  }

  void ed::
  v1 (const v1_type& x)
  {
    this->v1_.set (x);
  }

  const ed::v2_type& ed::
  v2 () const
  {
    return this->v2_.get ();
  }

  ed::v2_type& ed::
  v2 ()
  {
    return this->v2_.get ();
  }

  void ed::
  v2 (const v2_type& x)
  {
    this->v2_.set (x);
  }

  const ed::m_type& ed::
  m () const
  {
    return this->m_.get ();
  }

  ed::m_type& ed::
  m ()
  {
    return this->m_.get ();
  }

  void ed::
  m (const m_type& x)
  {
    this->m_.set (x);
  }

  void ed::
  m (::std::auto_ptr< m_type > x)
  {
    this->m_.set (x);
  }

  const ed::i_type& ed::
  i () const
  {
    return this->i_.get ();
  }

  ed::i_type& ed::
  i ()
  {
    return this->i_.get ();
  }

  void ed::
  i (const i_type& x)
  {
    this->i_.set (x);
  }


  // subdomains
  // 

  const subdomains::subdomain_sequence& subdomains::
  subdomain () const
  {
    return this->subdomain_;
  }

  subdomains::subdomain_sequence& subdomains::
  subdomain ()
  {
    return this->subdomain_;
  }

  void subdomains::
  subdomain (const subdomain_sequence& s)
  {
    this->subdomain_ = s;
  }


  // subdomain
  // 

  const subdomain::vertices_optional& subdomain::
  vertices () const
  {
    return this->vertices_;
  }

  subdomain::vertices_optional& subdomain::
  vertices ()
  {
    return this->vertices_;
  }

  void subdomain::
  vertices (const vertices_type& x)
  {
    this->vertices_.set (x);
  }

  void subdomain::
  vertices (const vertices_optional& x)
  {
    this->vertices_ = x;
  }

  void subdomain::
  vertices (::std::auto_ptr< vertices_type > x)
  {
    this->vertices_.set (x);
  }

  const subdomain::elements_optional& subdomain::
  elements () const
  {
    return this->elements_;
  }

  subdomain::elements_optional& subdomain::
  elements ()
  {
    return this->elements_;
  }

  void subdomain::
  elements (const elements_type& x)
  {
    this->elements_.set (x);
  }

  void subdomain::
  elements (const elements_optional& x)
  {
    this->elements_ = x;
  }

  void subdomain::
  elements (::std::auto_ptr< elements_type > x)
  {
    this->elements_.set (x);
  }

  const subdomain::boundary_edges_optional& subdomain::
  boundary_edges () const
  {
    return this->boundary_edges_;
  }

  subdomain::boundary_edges_optional& subdomain::
  boundary_edges ()
  {
    return this->boundary_edges_;
  }

  void subdomain::
  boundary_edges (const boundary_edges_type& x)
  {
    this->boundary_edges_.set (x);
  }

  void subdomain::
  boundary_edges (const boundary_edges_optional& x)
  {
    this->boundary_edges_ = x;
  }

  void subdomain::
  boundary_edges (::std::auto_ptr< boundary_edges_type > x)
  {
    this->boundary_edges_.set (x);
  }

  const subdomain::inner_edges_optional& subdomain::
  inner_edges () const
  {
    return this->inner_edges_;
  }

  subdomain::inner_edges_optional& subdomain::
  inner_edges ()
  {
    return this->inner_edges_;
  }

  void subdomain::
  inner_edges (const inner_edges_type& x)
  {
    this->inner_edges_.set (x);
  }

  void subdomain::
  inner_edges (const inner_edges_optional& x)
  {
    this->inner_edges_ = x;
  }

  void subdomain::
  inner_edges (::std::auto_ptr< inner_edges_type > x)
  {
    this->inner_edges_.set (x);
  }

  const subdomain::refinements_optional& subdomain::
  refinements () const
  {
    return this->refinements_;
  }

  subdomain::refinements_optional& subdomain::
  refinements ()
  {
    return this->refinements_;
  }

  void subdomain::
  refinements (const refinements_type& x)
  {
    this->refinements_.set (x);
  }

  void subdomain::
  refinements (const refinements_optional& x)
  {
    this->refinements_ = x;
  }

  void subdomain::
  refinements (::std::auto_ptr< refinements_type > x)
  {
    this->refinements_.set (x);
  }

  const subdomain::name_type& subdomain::
  name () const
  {
    return this->name_.get ();
  }

  subdomain::name_type& subdomain::
  name ()
  {
    return this->name_.get ();
  }

  void subdomain::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void subdomain::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // vertices
  // 

  const vertices::i_sequence& vertices::
  i () const
  {
    return this->i_;
  }

  vertices::i_sequence& vertices::
  i ()
  {
    return this->i_;
  }

  void vertices::
  i (const i_sequence& s)
  {
    this->i_ = s;
  }


  // elements
  // 

  const elements::i_sequence& elements::
  i () const
  {
    return this->i_;
  }

  elements::i_sequence& elements::
  i ()
  {
    return this->i_;
  }

  void elements::
  i (const i_sequence& s)
  {
    this->i_ = s;
  }


  // boundary_edges
  // 

  const boundary_edges::i_sequence& boundary_edges::
  i () const
  {
    return this->i_;
  }

  boundary_edges::i_sequence& boundary_edges::
  i ()
  {
    return this->i_;
  }

  void boundary_edges::
  i (const i_sequence& s)
  {
    this->i_ = s;
  }


  // inner_edges
  // 

  const inner_edges::i_sequence& inner_edges::
  i () const
  {
    return this->i_;
  }

  inner_edges::i_sequence& inner_edges::
  i ()
  {
    return this->i_;
  }

  void inner_edges::
  i (const i_sequence& s)
  {
    this->i_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace XMLSubdomains
{
  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::XMLSubdomains::t_t >
  _xsd_t_element_factory_init (
    "el",
    "XMLSubdomains",
    "t",
    "XMLSubdomains");


  static
  const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::XMLSubdomains::q_t >
  _xsd_q_element_factory_init (
    "el",
    "XMLSubdomains",
    "q",
    "XMLSubdomains");


  // elements_type
  //

  elements_type::
  elements_type ()
  : ::xml_schema::type (),
    el_ (::xml_schema::flags (), this)
  {
  }

  elements_type::
  elements_type (const elements_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    el_ (x.el_, f, this)
  {
  }

  elements_type::
  elements_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    el_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void elements_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // el
      //
      {
        ::xsd::cxx::tree::type_factory_map< char >& tfm (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ());

        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          tfm.create (
            "el",
            "XMLSubdomains",
            &::xsd::cxx::tree::factory_impl< el_type >,
            true, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< el_type > r (
            dynamic_cast< el_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->el_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  elements_type* elements_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class elements_type (*this, f, c);
  }

  elements_type::
  ~elements_type ()
  {
  }

  // el_t
  //

  el_t::
  el_t (const v1_type& v1,
        const v2_type& v2,
        const v3_type& v3,
        const m_type& m,
        const i_type& i)
  : ::xml_schema::type (),
    v1_ (v1, ::xml_schema::flags (), this),
    v2_ (v2, ::xml_schema::flags (), this),
    v3_ (v3, ::xml_schema::flags (), this),
    m_ (m, ::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this)
  {
  }

  el_t::
  el_t (const el_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    v1_ (x.v1_, f, this),
    v2_ (x.v2_, f, this),
    v3_ (x.v3_, f, this),
    m_ (x.m_, f, this),
    i_ (x.i_, f, this)
  {
  }

  el_t::
  el_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    v1_ (f, this),
    v2_ (f, this),
    v3_ (f, this),
    m_ (f, this),
    i_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void el_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v1" && n.namespace_ ().empty ())
      {
        this->v1_.set (v1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v2" && n.namespace_ ().empty ())
      {
        this->v2_.set (v2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v3" && n.namespace_ ().empty ())
      {
        this->v3_.set (v3_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "m" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< m_type > r (
          m_traits::create (i, f, this));

        this->m_.set (r);
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }
    }

    if (!v1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v1",
        "");
    }

    if (!v2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v2",
        "");
    }

    if (!v3_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v3",
        "");
    }

    if (!m_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "m",
        "");
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }
  }

  el_t* el_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class el_t (*this, f, c);
  }

  el_t::
  ~el_t ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, el_t >
  _xsd_el_t_type_factory_init (
    "el_t",
    "XMLSubdomains");

  // t_t
  //

  t_t::
  t_t (const v1_type& v1,
       const v2_type& v2,
       const v3_type& v3,
       const m_type& m,
       const i_type& i)
  : ::XMLSubdomains::el_t (v1,
                           v2,
                           v3,
                           m,
                           i)
  {
  }

  t_t::
  t_t (const t_t& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::XMLSubdomains::el_t (x, f, c)
  {
  }

  t_t::
  t_t (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::XMLSubdomains::el_t (e, f, c)
  {
  }

  t_t* t_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class t_t (*this, f, c);
  }

  t_t::
  ~t_t ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, t_t >
  _xsd_t_t_type_factory_init (
    "t_t",
    "XMLSubdomains");

  // q_t
  //

  q_t::
  q_t (const v1_type& v1,
       const v2_type& v2,
       const v3_type& v3,
       const m_type& m,
       const i_type& i,
       const v4_type& v4)
  : ::XMLSubdomains::el_t (v1,
                           v2,
                           v3,
                           m,
                           i),
    v4_ (v4, ::xml_schema::flags (), this)
  {
  }

  q_t::
  q_t (const q_t& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::XMLSubdomains::el_t (x, f, c),
    v4_ (x.v4_, f, this)
  {
  }

  q_t::
  q_t (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::XMLSubdomains::el_t (e, f | ::xml_schema::flags::base, c),
    v4_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void q_t::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::XMLSubdomains::el_t::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v4" && n.namespace_ ().empty ())
      {
        this->v4_.set (v4_traits::create (i, f, this));
        continue;
      }
    }

    if (!v4_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v4",
        "");
    }
  }

  q_t* q_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class q_t (*this, f, c);
  }

  q_t::
  ~q_t ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, q_t >
  _xsd_q_t_type_factory_init (
    "q_t",
    "XMLSubdomains");

  // edges_type
  //

  edges_type::
  edges_type ()
  : ::xml_schema::type (),
    ed_ (::xml_schema::flags (), this)
  {
  }

  edges_type::
  edges_type (const edges_type& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ed_ (x.ed_, f, this)
  {
  }

  edges_type::
  edges_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ed_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void edges_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ed
      //
      if (n.name () == "ed" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ed_type > r (
          ed_traits::create (i, f, this));

        this->ed_.push_back (r);
        continue;
      }

      break;
    }
  }

  edges_type* edges_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class edges_type (*this, f, c);
  }

  edges_type::
  ~edges_type ()
  {
  }

  // domain
  //

  domain::
  domain (const vertices_type& vertices,
          const elements_type& elements,
          const edges_type& edges,
          const subdomains_type& subdomains)
  : ::xml_schema::type (),
    variables_ (::xml_schema::flags (), this),
    vertices_ (vertices, ::xml_schema::flags (), this),
    elements_ (elements, ::xml_schema::flags (), this),
    edges_ (edges, ::xml_schema::flags (), this),
    curves_ (::xml_schema::flags (), this),
    subdomains_ (subdomains, ::xml_schema::flags (), this)
  {
  }

  domain::
  domain (::std::auto_ptr< vertices_type >& vertices,
          ::std::auto_ptr< elements_type >& elements,
          ::std::auto_ptr< edges_type >& edges,
          ::std::auto_ptr< subdomains_type >& subdomains)
  : ::xml_schema::type (),
    variables_ (::xml_schema::flags (), this),
    vertices_ (vertices, ::xml_schema::flags (), this),
    elements_ (elements, ::xml_schema::flags (), this),
    edges_ (edges, ::xml_schema::flags (), this),
    curves_ (::xml_schema::flags (), this),
    subdomains_ (subdomains, ::xml_schema::flags (), this)
  {
  }

  domain::
  domain (const domain& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    variables_ (x.variables_, f, this),
    vertices_ (x.vertices_, f, this),
    elements_ (x.elements_, f, this),
    edges_ (x.edges_, f, this),
    curves_ (x.curves_, f, this),
    subdomains_ (x.subdomains_, f, this)
  {
  }

  domain::
  domain (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    variables_ (f, this),
    vertices_ (f, this),
    elements_ (f, this),
    edges_ (f, this),
    curves_ (f, this),
    subdomains_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void domain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // variables
      //
      if (n.name () == "variables" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< variables_type > r (
          variables_traits::create (i, f, this));

        if (!this->variables_)
        {
          this->variables_.set (r);
          continue;
        }
      }

      // vertices
      //
      if (n.name () == "vertices" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vertices_type > r (
          vertices_traits::create (i, f, this));

        if (!vertices_.present ())
        {
          this->vertices_.set (r);
          continue;
        }
      }

      // elements
      //
      if (n.name () == "elements" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< elements_type > r (
          elements_traits::create (i, f, this));

        if (!elements_.present ())
        {
          this->elements_.set (r);
          continue;
        }
      }

      // edges
      //
      if (n.name () == "edges" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< edges_type > r (
          edges_traits::create (i, f, this));

        if (!edges_.present ())
        {
          this->edges_.set (r);
          continue;
        }
      }

      // curves
      //
      if (n.name () == "curves" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< curves_type > r (
          curves_traits::create (i, f, this));

        if (!this->curves_)
        {
          this->curves_.set (r);
          continue;
        }
      }

      // subdomains
      //
      if (n.name () == "subdomains" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< subdomains_type > r (
          subdomains_traits::create (i, f, this));

        if (!subdomains_.present ())
        {
          this->subdomains_.set (r);
          continue;
        }
      }

      break;
    }

    if (!vertices_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vertices",
        "");
    }

    if (!elements_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "elements",
        "");
    }

    if (!edges_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "edges",
        "");
    }

    if (!subdomains_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "subdomains",
        "");
    }
  }

  domain* domain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class domain (*this, f, c);
  }

  domain::
  ~domain ()
  {
  }

  // ed
  //

  ed::
  ed (const v1_type& v1,
      const v2_type& v2,
      const m_type& m,
      const i_type& i)
  : ::xml_schema::type (),
    v1_ (v1, ::xml_schema::flags (), this),
    v2_ (v2, ::xml_schema::flags (), this),
    m_ (m, ::xml_schema::flags (), this),
    i_ (i, ::xml_schema::flags (), this)
  {
  }

  ed::
  ed (const ed& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    v1_ (x.v1_, f, this),
    v2_ (x.v2_, f, this),
    m_ (x.m_, f, this),
    i_ (x.i_, f, this)
  {
  }

  ed::
  ed (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    v1_ (f, this),
    v2_ (f, this),
    m_ (f, this),
    i_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void ed::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "v1" && n.namespace_ ().empty ())
      {
        this->v1_.set (v1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "v2" && n.namespace_ ().empty ())
      {
        this->v2_.set (v2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "m" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< m_type > r (
          m_traits::create (i, f, this));

        this->m_.set (r);
        continue;
      }

      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.set (i_traits::create (i, f, this));
        continue;
      }
    }

    if (!v1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v1",
        "");
    }

    if (!v2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "v2",
        "");
    }

    if (!m_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "m",
        "");
    }

    if (!i_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "i",
        "");
    }
  }

  ed* ed::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ed (*this, f, c);
  }

  ed::
  ~ed ()
  {
  }

  // subdomains
  //

  subdomains::
  subdomains ()
  : ::xml_schema::type (),
    subdomain_ (::xml_schema::flags (), this)
  {
  }

  subdomains::
  subdomains (const subdomains& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    subdomain_ (x.subdomain_, f, this)
  {
  }

  subdomains::
  subdomains (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    subdomain_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void subdomains::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // subdomain
      //
      if (n.name () == "subdomain" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< subdomain_type > r (
          subdomain_traits::create (i, f, this));

        this->subdomain_.push_back (r);
        continue;
      }

      break;
    }
  }

  subdomains* subdomains::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subdomains (*this, f, c);
  }

  subdomains::
  ~subdomains ()
  {
  }

  // subdomain
  //

  subdomain::
  subdomain (const name_type& name)
  : ::xml_schema::type (),
    vertices_ (::xml_schema::flags (), this),
    elements_ (::xml_schema::flags (), this),
    boundary_edges_ (::xml_schema::flags (), this),
    inner_edges_ (::xml_schema::flags (), this),
    refinements_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  subdomain::
  subdomain (const subdomain& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    vertices_ (x.vertices_, f, this),
    elements_ (x.elements_, f, this),
    boundary_edges_ (x.boundary_edges_, f, this),
    inner_edges_ (x.inner_edges_, f, this),
    refinements_ (x.refinements_, f, this),
    name_ (x.name_, f, this)
  {
  }

  subdomain::
  subdomain (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    vertices_ (f, this),
    elements_ (f, this),
    boundary_edges_ (f, this),
    inner_edges_ (f, this),
    refinements_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void subdomain::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // vertices
      //
      if (n.name () == "vertices" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< vertices_type > r (
          vertices_traits::create (i, f, this));

        if (!this->vertices_)
        {
          this->vertices_.set (r);
          continue;
        }
      }

      // elements
      //
      if (n.name () == "elements" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< elements_type > r (
          elements_traits::create (i, f, this));

        if (!this->elements_)
        {
          this->elements_.set (r);
          continue;
        }
      }

      // boundary_edges
      //
      if (n.name () == "boundary_edges" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< boundary_edges_type > r (
          boundary_edges_traits::create (i, f, this));

        if (!this->boundary_edges_)
        {
          this->boundary_edges_.set (r);
          continue;
        }
      }

      // inner_edges
      //
      if (n.name () == "inner_edges" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inner_edges_type > r (
          inner_edges_traits::create (i, f, this));

        if (!this->inner_edges_)
        {
          this->inner_edges_.set (r);
          continue;
        }
      }

      // refinements
      //
      if (n.name () == "refinements" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< refinements_type > r (
          refinements_traits::create (i, f, this));

        if (!this->refinements_)
        {
          this->refinements_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  subdomain* subdomain::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subdomain (*this, f, c);
  }

  subdomain::
  ~subdomain ()
  {
  }

  // vertices
  //

  vertices::
  vertices ()
  : ::xml_schema::type (),
    i_ (::xml_schema::flags (), this)
  {
  }

  vertices::
  vertices (const vertices& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    i_ (x.i_, f, this)
  {
  }

  vertices::
  vertices (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    i_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void vertices::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // i
      //
      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.push_back (i_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  vertices* vertices::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class vertices (*this, f, c);
  }

  vertices::
  ~vertices ()
  {
  }

  // elements
  //

  elements::
  elements ()
  : ::xml_schema::type (),
    i_ (::xml_schema::flags (), this)
  {
  }

  elements::
  elements (const elements& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    i_ (x.i_, f, this)
  {
  }

  elements::
  elements (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    i_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void elements::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // i
      //
      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.push_back (i_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  elements* elements::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class elements (*this, f, c);
  }

  elements::
  ~elements ()
  {
  }

  // boundary_edges
  //

  boundary_edges::
  boundary_edges ()
  : ::xml_schema::type (),
    i_ (::xml_schema::flags (), this)
  {
  }

  boundary_edges::
  boundary_edges (const boundary_edges& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    i_ (x.i_, f, this)
  {
  }

  boundary_edges::
  boundary_edges (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    i_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void boundary_edges::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // i
      //
      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.push_back (i_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  boundary_edges* boundary_edges::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class boundary_edges (*this, f, c);
  }

  boundary_edges::
  ~boundary_edges ()
  {
  }

  // inner_edges
  //

  inner_edges::
  inner_edges ()
  : ::xml_schema::type (),
    i_ (::xml_schema::flags (), this)
  {
  }

  inner_edges::
  inner_edges (const inner_edges& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    i_ (x.i_, f, this)
  {
  }

  inner_edges::
  inner_edges (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    i_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void inner_edges::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // i
      //
      if (n.name () == "i" && n.namespace_ ().empty ())
      {
        this->i_.push_back (i_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  inner_edges* inner_edges::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inner_edges (*this, f, c);
  }

  inner_edges::
  ~inner_edges ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace XMLSubdomains
{
  ::std::ostream&
  operator<< (::std::ostream& o, const elements_type& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (elements_type::el_const_iterator
           b (i.el ().begin ()), e (i.el ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "el: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const el_t& i)
  {
    o << ::std::endl << "v1: " << i.v1 ();
    o << ::std::endl << "v2: " << i.v2 ();
    o << ::std::endl << "v3: " << i.v3 ();
    o << ::std::endl << "m: " << i.m ();
    o << ::std::endl << "i: " << i.i ();
    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, el_t >
  _xsd_el_t_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const t_t& i)
  {
    o << static_cast< const ::XMLSubdomains::el_t& > (i);

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, t_t >
  _xsd_t_t_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const q_t& i)
  {
    o << static_cast< const ::XMLSubdomains::el_t& > (i);

    o << ::std::endl << "v4: " << i.v4 ();
    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, q_t >
  _xsd_q_t_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const edges_type& i)
  {
    for (edges_type::ed_const_iterator
         b (i.ed ().begin ()), e (i.ed ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ed: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const domain& i)
  {
    if (i.variables ())
    {
      o << ::std::endl << "variables: " << *i.variables ();
    }

    o << ::std::endl << "vertices: " << i.vertices ();
    o << ::std::endl << "elements: " << i.elements ();
    o << ::std::endl << "edges: " << i.edges ();
    if (i.curves ())
    {
      o << ::std::endl << "curves: " << *i.curves ();
    }

    o << ::std::endl << "subdomains: " << i.subdomains ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ed& i)
  {
    o << ::std::endl << "v1: " << i.v1 ();
    o << ::std::endl << "v2: " << i.v2 ();
    o << ::std::endl << "m: " << i.m ();
    o << ::std::endl << "i: " << i.i ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const subdomains& i)
  {
    for (subdomains::subdomain_const_iterator
         b (i.subdomain ().begin ()), e (i.subdomain ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "subdomain: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const subdomain& i)
  {
    if (i.vertices ())
    {
      o << ::std::endl << "vertices: " << *i.vertices ();
    }

    if (i.elements ())
    {
      o << ::std::endl << "elements: " << *i.elements ();
    }

    if (i.boundary_edges ())
    {
      o << ::std::endl << "boundary_edges: " << *i.boundary_edges ();
    }

    if (i.inner_edges ())
    {
      o << ::std::endl << "inner_edges: " << *i.inner_edges ();
    }

    if (i.refinements ())
    {
      o << ::std::endl << "refinements: " << *i.refinements ();
    }

    o << ::std::endl << "name: " << i.name ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const vertices& i)
  {
    for (vertices::i_const_iterator
         b (i.i ().begin ()), e (i.i ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "i: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const elements& i)
  {
    for (elements::i_const_iterator
         b (i.i ().begin ()), e (i.i ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "i: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const boundary_edges& i)
  {
    for (boundary_edges::i_const_iterator
         b (i.i ().begin ()), e (i.i ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "i: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const inner_edges& i)
  {
    for (inner_edges::i_const_iterator
         b (i.i ().begin ()), e (i.i ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "i: " << *b;
    }

    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace XMLSubdomains
{
  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSubdomains::domain_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSubdomains::domain_ (isrc, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::XMLSubdomains::domain_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::XMLSubdomains::domain > r (
      ::XMLSubdomains::domain_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::XMLSubdomains::domain > r (
        ::XMLSubdomains::domain_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "domain" &&
        n.namespace_ () == "XMLSubdomains")
    {
      ::std::auto_ptr< ::XMLSubdomains::domain > r (
        ::xsd::cxx::tree::traits< ::XMLSubdomains::domain, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "domain",
      "XMLSubdomains");
  }

  ::std::auto_ptr< ::XMLSubdomains::domain >
  domain_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "domain" &&
        n.namespace_ () == "XMLSubdomains")
    {
      ::std::auto_ptr< ::XMLSubdomains::domain > r (
        ::xsd::cxx::tree::traits< ::XMLSubdomains::domain, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "domain",
      "XMLSubdomains");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace XMLSubdomains
{
  void
  domain_ (::std::ostream& o,
           const ::XMLSubdomains::domain& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLSubdomains::domain_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  domain_ (::std::ostream& o,
           const ::XMLSubdomains::domain& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLSubdomains::domain_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  domain_ (::std::ostream& o,
           const ::XMLSubdomains::domain& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLSubdomains::domain_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  domain_ (::xercesc::XMLFormatTarget& t,
           const ::XMLSubdomains::domain& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLSubdomains::domain_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  domain_ (::xercesc::XMLFormatTarget& t,
           const ::XMLSubdomains::domain& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLSubdomains::domain_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  domain_ (::xercesc::XMLFormatTarget& t,
           const ::XMLSubdomains::domain& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::XMLSubdomains::domain_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  domain_ (::xercesc::DOMDocument& d,
           const ::XMLSubdomains::domain& s,
           ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "domain" &&
        n.namespace_ () == "XMLSubdomains")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "domain",
        "XMLSubdomains");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  domain_ (const ::XMLSubdomains::domain& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "domain",
        "XMLSubdomains",
        m, f));

    ::XMLSubdomains::domain_ (*d, s, f);
    return d;
  }

  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::XMLSubdomains::t_t >
  _xsd_t_element_serializer_init (
    "el",
    "XMLSubdomains",
    "t",
    "XMLSubdomains");


  static
  const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::XMLSubdomains::q_t >
  _xsd_q_element_serializer_init (
    "el",
    "XMLSubdomains",
    "q",
    "XMLSubdomains");


  void
  operator<< (::xercesc::DOMElement& e, const elements_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // el
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (elements_type::el_const_iterator
           b (i.el ().begin ()), n (i.el ().end ());
           b != n; ++b)
      {
        if (typeid (elements_type::el_type) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "el",
              "XMLSubdomains",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "el",
            "XMLSubdomains",
            true, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const el_t& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // v1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v1",
          e));

      a << i.v1 ();
    }

    // v2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v2",
          e));

      a << i.v2 ();
    }

    // v3
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v3",
          e));

      a << i.v3 ();
    }

    // m
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "m",
          e));

      a << i.m ();
    }

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, el_t >
  _xsd_el_t_type_serializer_init (
    "el_t",
    "XMLSubdomains");


  void
  operator<< (::xercesc::DOMElement& e, const t_t& i)
  {
    e << static_cast< const ::XMLSubdomains::el_t& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, t_t >
  _xsd_t_t_type_serializer_init (
    "t_t",
    "XMLSubdomains");


  void
  operator<< (::xercesc::DOMElement& e, const q_t& i)
  {
    e << static_cast< const ::XMLSubdomains::el_t& > (i);

    // v4
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v4",
          e));

      a << i.v4 ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, q_t >
  _xsd_q_t_type_serializer_init (
    "q_t",
    "XMLSubdomains");


  void
  operator<< (::xercesc::DOMElement& e, const edges_type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // ed
    //
    for (edges_type::ed_const_iterator
         b (i.ed ().begin ()), n (i.ed ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ed",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const domain& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // variables
    //
    if (i.variables ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variables",
          e));

      s << *i.variables ();
    }

    // vertices
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vertices",
          e));

      s << i.vertices ();
    }

    // elements
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elements",
          e));

      s << i.elements ();
    }

    // edges
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "edges",
          e));

      s << i.edges ();
    }

    // curves
    //
    if (i.curves ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "curves",
          e));

      s << *i.curves ();
    }

    // subdomains
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subdomains",
          e));

      s << i.subdomains ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ed& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // v1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v1",
          e));

      a << i.v1 ();
    }

    // v2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "v2",
          e));

      a << i.v2 ();
    }

    // m
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "m",
          e));

      a << i.m ();
    }

    // i
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "i",
          e));

      a << i.i ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const subdomains& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // subdomain
    //
    for (subdomains::subdomain_const_iterator
         b (i.subdomain ().begin ()), n (i.subdomain ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subdomain",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const subdomain& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // vertices
    //
    if (i.vertices ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "vertices",
          e));

      s << *i.vertices ();
    }

    // elements
    //
    if (i.elements ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elements",
          e));

      s << *i.elements ();
    }

    // boundary_edges
    //
    if (i.boundary_edges ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "boundary_edges",
          e));

      s << *i.boundary_edges ();
    }

    // inner_edges
    //
    if (i.inner_edges ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inner_edges",
          e));

      s << *i.inner_edges ();
    }

    // refinements
    //
    if (i.refinements ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "refinements",
          e));

      s << *i.refinements ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const vertices& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // i
    //
    for (vertices::i_const_iterator
         b (i.i ().begin ()), n (i.i ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "i",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const elements& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // i
    //
    for (elements::i_const_iterator
         b (i.i ().begin ()), n (i.i ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "i",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const boundary_edges& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // i
    //
    for (boundary_edges::i_const_iterator
         b (i.i ().begin ()), n (i.i ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "i",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const inner_edges& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // i
    //
    for (inner_edges::i_const_iterator
         b (i.i ().begin ()), n (i.i ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "i",
          e));

      s << *b;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

